function fizzbuzz(var n){
    let r = [1 .... n+1]
    for(let i : r){
        if(i % 3 == 0){
            console.log("Fizzbuzz")
        }
    }
}

fizzbuzz(20)


program -> statementList
statementList -> statement*
statement ->
            | varStmt
            | forStmt
            | ifStmt
            | printStmt
            | funcCallStmt
            | exprStmt
funcCallStmt -> IDENTIFIER "(" expr ")"\n
funcDeclStmt -> def IDENTIFIER "(" IDENTIFIER ")" ":" \n
ifStmt -> if expr :\n \t program
varStmt -> IDENTIFIER = EXPR
exprStmt -> expr\n
expr -> inline
inline -> comparison "if" comparison "else" inline | comparison

(5 if True else (6 if True else 7)) -> Right to left

((5 if True else 6) if True else 7) -> Left to right

f(a,b,c)
f(f(a),c)
f(a)
f()

func -> identifier()
comparison -> comparison (< | <= | >= | > ) equality | equality
equality -> equality (!= | ==) binary | binary
orExpr -> orExpr or andExpr | andExpr 
andExpr -> andExpr and unary | orExpr
unary -> - not unary | term
term -> term + factor | term - factor | factor 
factor -> factor * primary | factor / primary | primary  
primary -> IDENTIFIER | NUMBER | BOOLEAN | STRING | (expr)

parse(){
    stmtList = []
p    while(current < tokens.length){
        parseRootStmt()
        advance()
    }
}

parseRootStmt(){
    stmt;
    match(def) -> stmt = varStmt()
    match(for) -> stmt = forStmt()
    consume(NEWLINE,"")
    stmtList.push_back(stmt)
}

parseVarStmt(){
    i = consume(IDENTIEIFER,"No identifier")
    consume(EQUAL,"no equal")
    expr = parseRootExpr()

    return Stmt.Var(i,expr)
}

parseRootExpr(){

}
parseInlineExpr(){

}


1 + 2 + 3
((1+2) + 3)

1 >= 2 >= 3

1 + 5 * 5 + 3 = 1 + (5 * 5) + 3

-1 + 5 * 5 + 3
            term        +       factor
         term   +   factor         neg
        factor    factor * neg     primary
         neg        neg   primary     3
       - primary   primary   5
          1          5

term -> term (+ | -) factor | factor
factor -> factor (* | /) neg | neg
neg -> - primary | primary
primary -> NUMBER

(
    EQUALITY 
    left:(
            EQUALITY left:(PRIMARY {type:INT,value:5}), 
            right:(AND left:(PRIMARY {type:INT,value:5}), right:(PRIMARY {type:INT,value:5})), 
            equalityOperator:not_equal !=
        ), 
    right:(
        OR 
        left:(
            TERM 
            left:(PRIMARY {type:INT,value:1}), 
            right:(PRIMARY {type:INT,value:3}), 
            termOperator:plus +
        ), 
        right:(NOT body:(PRIMARY {type:BOOLEAN,value:1}))
        ), 
    equalityOperator:double_equal ==
)


funcDecl
    def identifier ( identifier ) :

funcInv
    identifier ( identifier )

condStatement
    | ifStatement
    | ifStatement
      elifStatement*
      elseStatement*

ifStatement
    if expr :
    \t  body

elif statement 
    elif expr:
        body

else statement
    else:
        body
        
forStatement:
    | for identifier in identifier
    | for identifier in range(num,num):


if if
expr expr
tab tab
identifier x
plus +
equal equal
num 5

start and end of the body?
start = header + tab
end = header - tab*


stack?

if True:
    2 + 2


if if
bool True
: :
newline \n
tab \t
num 2
plus plus
num 2
newline \n

if True:
    if True:
        2 + 2
    return False
    

if if
bool True
: :
newline \n
tab \t
if if
bool True
: :
newline \n
tab \t
tab \t
num 2
plus plus
num 2
newline \n
tab \t
return return
False False
newline \n


recursively or stack wise?

statement -> toJSString()

parseStatement(indent = 0):
    match 
        funcDecl
        funcInv
        ifStatement
        elifStatement
        elseStatement
        exprStatement
        returnStatement
        varSetStatement
parseFuncDecl

